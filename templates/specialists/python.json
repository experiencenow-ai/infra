{
  "name": "python",
  "domain": "Python best practices and debugging",
  "created_by": "system",
  "created_at": "2025-01-15T00:00:00Z",
  "version": 1,
  "knowledge": "Python debugging:\n- Use py_compile to check syntax: python3 -m py_compile file.py\n- Use -m flag for module execution: python3 -m module.name\n- Print debugging: print(f'{var=}') shows name and value\n- pdb: import pdb; pdb.set_trace() for interactive debugging\n- Traceback: read bottom-up, last line is the error\n\nCommon errors:\n- ImportError: module not found or circular import\n- AttributeError: object doesn't have that attribute\n- TypeError: wrong type passed to function\n- KeyError: dict key doesn't exist\n- IndentationError: mixed tabs/spaces or wrong level\n\nBest practices:\n- Type hints: def func(x: int) -> str:\n- Docstrings: \"\"\"One line summary.\\n\\nDetails.\"\"\"\n- f-strings over .format(): f'{name} is {age}'\n- Context managers: with open(...) as f:\n- List comprehensions: [x*2 for x in items if x > 0]\n- pathlib over os.path: Path('/home') / 'user'\n\nTesting:\n- pytest: simple test functions, auto-discovery\n- assert statements: assert result == expected\n- Fixtures: @pytest.fixture for setup/teardown\n- Coverage: pytest --cov=module",
  "examples": "# Check syntax before running\npython3 -m py_compile modules/email_client.py\n\n# Debug with breakpoint\ndef buggy_function(data):\n    for item in data:\n        breakpoint()  # Python 3.7+, same as pdb.set_trace()\n        result = process(item)\n    return result\n\n# Safe dict access\nvalue = config.get('key', default_value)\n\n# Safe attribute access\nresult = getattr(obj, 'method', lambda: None)()\n\n# Exception handling with context\ntry:\n    risky_operation()\nexcept SpecificError as e:\n    logger.error(f'Operation failed: {e}')\n    raise  # Re-raise with original traceback\n\n# Path handling\nfrom pathlib import Path\nconfig_path = Path.home() / '.config' / 'app' / 'config.json'\nif config_path.exists():\n    data = json.loads(config_path.read_text())\n\n# Type-safe JSON loading\nfrom typing import Any\ndef load_json(path: Path) -> dict[str, Any]:\n    try:\n        return json.loads(path.read_text())\n    except (json.JSONDecodeError, FileNotFoundError):\n        return {}",
  "patterns": "- Always use pathlib for file paths\n- Prefer explicit exceptions over bare except\n- Use type hints for function signatures\n- Test edge cases: empty input, None, large data\n- Log errors with context (what was being attempted)\n- Use __name__ == '__main__' for script entry points\n- Keep functions under 50 lines"
}
